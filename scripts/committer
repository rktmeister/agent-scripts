#!/usr/bin/env bash

set -euo pipefail
# Disable glob expansion to handle brackets in file paths
set -f

usage() {
  printf 'Usage: %s [--force] "commit message" "file" ["file" ...]\n' "$(basename "$0")" >&2
  exit 2
}

if [ "$#" -lt 2 ]; then
  usage
fi

force_delete_lock=false
if [ "${1:-}" = "--force" ]; then
  force_delete_lock=true
  shift
fi

if [ "$#" -lt 2 ]; then
  usage
fi

commit_message=$1
shift

if [[ "$commit_message" != *[![:space:]]* ]]; then
  printf 'Error: commit message must not be empty\n' >&2
  exit 1
fi

if [ -e "$commit_message" ]; then
  printf 'Error: first argument looks like a file path ("%s"); provide the commit message first\n' "$commit_message" >&2
  exit 1
fi

if [ "$#" -eq 0 ]; then
  usage
fi

files=("$@")

# Disallow "." because it stages the entire repository and defeats the helper's safety guardrails.
for file in "${files[@]}"; do
  if [ "$file" = "." ]; then
    printf 'Error: "." is not allowed; list specific paths instead\n' >&2
    exit 1
  fi
done

# Validate paths exist (or are valid tracked paths for deletions).
# Do this against the *real* index/HEAD; we don't want to depend on our isolated index.
head_ok=false
if git rev-parse --verify HEAD >/dev/null 2>&1; then
  head_ok=true
fi

for file in "${files[@]}"; do
  if [ ! -e "$file" ]; then
    if [ "$head_ok" = true ]; then
      # Allow staging deletions: when a file is removed from disk, it may no longer exist in the index
      # (once staged for deletion), but it can still exist in HEAD.
      if ! git ls-files --error-unmatch -- "$file" >/dev/null 2>&1; then
        if ! git cat-file -e "HEAD:$file" >/dev/null 2>&1; then
          printf 'Error: file not found: %s\n' "$file" >&2
          exit 1
        fi
      fi
    else
      printf 'Error: file not found: %s\n' "$file" >&2
      exit 1
    fi
  fi
done

# Warn if the user already has staged changes in the shared index.
# We do NOT touch the shared index; this helper uses an isolated index per invocation.
if ! git diff --staged --quiet; then
  printf 'Warning: existing staged changes detected; committer will not use or modify them\n' >&2
fi

last_commit_error=''

run_git_commit() {
  local stderr_log
  stderr_log=$(mktemp)
  if git commit -m "$commit_message" 2> >(tee "$stderr_log" >&2); then
    rm -f "$stderr_log"
    last_commit_error=''
    return 0
  fi

  last_commit_error=$(cat "$stderr_log")
  rm -f "$stderr_log"
  return 1
}

# Serialize commits to avoid two committer invocations racing and producing commits based on a stale HEAD.
# This does not prevent *manual* git commits; the guardrail is to always use committer.
git_dir=$(git rev-parse --git-dir)
lock_dir_path="$git_dir/.committer-lock"
lock_acquired=false

tmp_index=''
base_head=''

cleanup() {
  if [ -n "${tmp_index:-}" ]; then
    rm -f "$tmp_index" "$tmp_index.lock" 2>/dev/null || true
  fi

  # Only remove the commit lock if we acquired it.
  if [ "$lock_acquired" = true ] && [ -n "${lock_dir_path:-}" ]; then
    rm -rf "$lock_dir_path" 2>/dev/null || true
  fi
}
trap cleanup EXIT

acquire_lock() {
  while true; do
    if mkdir "$lock_dir_path" 2>/dev/null; then
      lock_acquired=true
      printf '%s\n' "$$" >"$lock_dir_path/pid"
      date +%s >"$lock_dir_path/ts" 2>/dev/null || true
      return 0
    fi

    # Auto-clear stale lock if owning PID is gone.
    if [ -f "$lock_dir_path/pid" ]; then
      local owner_pid
      owner_pid=$(cat "$lock_dir_path/pid" 2>/dev/null || true)
      if [ -n "$owner_pid" ] && ! kill -0 "$owner_pid" 2>/dev/null; then
        rm -rf "$lock_dir_path" 2>/dev/null || true
        continue
      fi
    fi

    sleep 0.1
  done
}

acquire_lock

# Isolated index: prevents stomping other agents' staged state in .git/index.
tmp_index=$(mktemp "${TMPDIR:-/tmp}/committer-index.XXXXXX")
export GIT_INDEX_FILE="$tmp_index"

if git rev-parse --verify HEAD >/dev/null 2>&1; then
  base_head=$(git rev-parse HEAD)
  git read-tree HEAD
else
  base_head=''
  git read-tree --empty
fi

git add -A -- "${files[@]}"

if git diff --staged --quiet; then
  printf 'Warning: no staged changes detected for: %s\n' "${files[*]}" >&2
  exit 1
fi

# If HEAD moved since we populated the index (shouldn't happen if everyone uses committer), abort.
if [ -n "$base_head" ]; then
  current_head=$(git rev-parse HEAD)
  if [ "$current_head" != "$base_head" ]; then
    printf 'Error: HEAD moved while preparing commit (%s -> %s); re-run committer\n' "$base_head" "$current_head" >&2
    exit 1
  fi
fi

committed=false
if run_git_commit; then
  committed=true
elif [ "$force_delete_lock" = true ]; then
  lock_path=$(
    printf '%s\n' "$last_commit_error" |
      awk -F"'" '/Unable to create .*index\.lock/ { print $2; exit }'
  )

  if [ -n "$lock_path" ] && [ -e "$lock_path" ]; then
    rm -f "$lock_path"
    printf 'Removed stale git lock: %s\n' "$lock_path" >&2
    if run_git_commit; then
      committed=true
    fi
  fi
fi

if [ "$committed" = false ]; then
  exit 1
fi

printf 'Committed "%s" with %d files\n' "$commit_message" "${#files[@]}"
